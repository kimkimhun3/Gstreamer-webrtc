<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>WebRTC Viewer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 0; padding: 16px; background: #0b0c10; color: #e5e7eb; }
    .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    button { padding: 8px 14px; border-radius: 8px; border: 1px solid #374151; background: #111827; color: #e5e7eb; cursor: pointer; }
    button:hover { background: #1f2937; }
    #status { padding: 6px 10px; border-radius: 6px; background: #111827; border: 1px solid #374151; }
    video { width: 100%; max-width: 960px; background: #111; border-radius: 12px; border: 1px solid #374151; }
    pre { background: #111827; padding: 8px; border-radius: 8px; overflow: auto; border: 1px solid #374151; max-height: 30vh; }
    .muted { opacity: 0.8; }
  </style>
</head>
<body>
  <h1>WebRTC Viewer</h1>

  <div class="row" style="margin-bottom:12px">
    <button id="btnConnect">Connect</button>
    <button id="btnDisconnect">Disconnect</button>
    <span id="status">idle</span>
  </div>

  <video id="video" autoplay playsinline muted class="muted" controls></video>

  <h3>Logs</h3>
  <pre id="log"></pre>

<script>
(() => {
  const WS_URL = (location.protocol === 'https:' ? 'wss://' : 'ws://') + location.hostname + ':8080/';

  /*** UI ***/
  const $video = document.getElementById('video');
  const $status = document.getElementById('status');
  const $log = document.getElementById('log');
  const $btnConnect = document.getElementById('btnConnect');
  const $btnDisconnect = document.getElementById('btnDisconnect');

  function log(...args) {
    const line = args.map(a => typeof a === 'string' ? a : JSON.stringify(a)).join(' ');
    console.log('[viewer]', ...args);
    $log.textContent += line + '\n';
    $log.scrollTop = $log.scrollHeight;
  }

  function updateStatus(txt) {
    $status.textContent = txt;
  }

  /*** State ***/
  let ws = null;
  let pc = null;
  let remoteStream = null;
  let myId = null;
  let remoteId = null;
  let srcSet = false;
  let playPending = null;

  /*** Cleanup ***/
  function cleanupPC() {
    if (pc) {
      try { pc.ontrack = null; } catch {}
      try { pc.onicecandidate = null; } catch {}
      try { pc.onconnectionstatechange = null; } catch {}
      try { pc.onicegatheringstatechange = null; } catch {}
      try { pc.close(); } catch {}
      pc = null;
    }
    remoteStream = null;
    srcSet = false;
    playPending = null;
  }

  function cleanupMediaElement() {
    try { $video.pause(); } catch {}
    $video.srcObject = null;
    $video.classList.add('muted');
  }

  function cleanupWS() {
    if (ws) {
      try { ws.onopen = ws.onmessage = ws.onclose = ws.onerror = null; } catch {}
      try { ws.close(); } catch {}
      ws = null;
    }
  }

  function fullCleanup() {
    cleanupPC();
    cleanupMediaElement();
    cleanupWS();
    myId = null;
    remoteId = null;
  }

  /*** PeerConnection ***/
  function setupPeerConnection() {
    pc = new RTCPeerConnection({
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    });

    remoteStream = new MediaStream();
    srcSet = false;
    playPending = null;

    pc.ontrack = (ev) => {
      const track = ev.track;
      log('✓ Received track:', track.kind, 'readyState:', track.readyState);

      // Always add to a single persistent stream
      remoteStream.addTrack(track);

      // Set srcObject exactly once per connection
      if (!srcSet) {
        srcSet = true;
        $video.srcObject = remoteStream;

        // Defer play() so both audio+video can arrive first
        queueMicrotask(() => {
          if (!playPending) {
            playPending = $video.play().then(() => {
              log('✓ Video playing (autoplay)');
              $video.classList.remove('muted');
            }).catch(err => {
              log('✗ Video play failed (will retry on canplay):', err.name, err.message);
            });
          }
        });
      }
    };

    // Retry play if the first attempt was interrupted
    $video.addEventListener('canplay', () => {
      if ($video.paused) {
        $video.play().then(() => {
          log('✓ Video playing (canplay retry)');
          $video.classList.remove('muted');
        }).catch(() => {});
      }
    }, { once: false });

    // iOS sometimes pauses on background
    document.addEventListener('visibilitychange', () => {
      if (!document.hidden && $video.paused) {
        $video.play().catch(() => {});
      }
    });

    pc.onicecandidate = (ev) => {
      if (ev.candidate && ws && ws.readyState === WebSocket.OPEN) {
        const msg = {
          type: 'ice-candidate',
          to: remoteId || undefined,
          candidate: {
            candidate: ev.candidate.candidate,
            sdpMLineIndex: ev.candidate.sdpMLineIndex
            // omit sdpMid to avoid mismatches across renegotiations
          }
        };
        ws.send(JSON.stringify(msg));
        log('Generated ICE candidate:', ev.candidate.candidate);
      }
    };

    pc.onconnectionstatechange = () => {
      log('Connection state:', pc.connectionState);
      if (pc.connectionState === 'connected') {
        updateStatus('connected');
        log('✓ WebRTC connection established');
      } else if (pc.connectionState === 'failed' || pc.connectionState === 'closed') {
        updateStatus(pc.connectionState);
      }
    };

    pc.onicegatheringstatechange = () => {
      log('ICE gathering state:', pc.iceGatheringState);
    };

    return pc;
  }

  /*** WebSocket ***/
  function connectWS() {
    cleanupWS();
    ws = new WebSocket(WS_URL);

    ws.onopen = () => {
      log('WebSocket connected');
      updateStatus('ws:open');
    };

    ws.onclose = () => {
      log('WebSocket disconnected');
      updateStatus('ws:closed');
    };

    ws.onerror = (e) => {
      log('WebSocket error:', e.message || e);
      updateStatus('ws:error');
    };

    ws.onmessage = async (ev) => {
      let data = null;
      try { data = JSON.parse(ev.data); } catch { return; }

      log('Received:', data.type);

      switch (data.type) {
        case 'registered': {
          myId = data.id;
          log('My ID:', myId);

          // New PC per connection lifecycle
          cleanupPC();
          cleanupMediaElement();
          setupPeerConnection();

          // Ask the sender to create an offer
          ws.send(JSON.stringify({ type: 'request-offer' }));
          log('request-offer sent');
          break;
        }

        case 'offer': {
          // server may broadcast offers; pick the sender advertised in 'from'
          remoteId = data.from || remoteId;
          log('Handling offer from:', remoteId);

          if (!pc) setupPeerConnection();

          await pc.setRemoteDescription({ type: 'offer', sdp: data.sdp });
          log('✓ Remote description set');

          const answer = await pc.createAnswer();
          await pc.setLocalDescription(answer);
          log('✓ Local description set');

          ws.send(JSON.stringify({ type: 'answer', to: remoteId, sdp: answer.sdp }));
          log('✓ Answer sent');
          break;
        }

        case 'ice-candidate': {
          if (data.candidate && pc) {
            try {
              await pc.addIceCandidate({
                candidate: data.candidate.candidate,
                sdpMLineIndex: data.candidate.sdpMLineIndex
                // omit sdpMid on purpose
              });
              log('✓ Added ICE candidate');
            } catch (e) {
              log('✗ addIceCandidate error:', e);
            }
          }
          break;
        }

        case 'peer-left': {
          if (remoteId && data.id === remoteId) {
            log('Peer left:', remoteId);
            // full reset so the next connect is clean
            cleanupPC();
            cleanupMediaElement();
            remoteId = null;
            updateStatus('peer-left');
          }
          break;
        }

        default:
          // ignore
          break;
      }
    };
  }

  /*** Buttons ***/
  $btnConnect.addEventListener('click', () => {
    fullCleanup();          // ensure pristine state
    connectWS();
    updateStatus('connecting');
  });

  $btnDisconnect.addEventListener('click', () => {
    fullCleanup();
    updateStatus('disconnected');
  });

  // Optional: auto-connect on page load
  // connectWS();
})();
</script>
</body>
</html>
